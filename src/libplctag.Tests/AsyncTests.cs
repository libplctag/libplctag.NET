using System;
using Xunit;
using Moq;
using System.Threading;
using System.Threading.Tasks;
using libplctag.NativeImport;

namespace libplctag.Tests
{
    public class AsyncTests
    {

        readonly TimeSpan REALISTIC_LATENCY_FOR_CREATE = TimeSpan.FromMilliseconds(50);
        readonly TimeSpan REALISTIC_LATENCY_FOR_READ = TimeSpan.FromMilliseconds(50);
        readonly TimeSpan REALISTIC_TIMEOUT_FOR_ALL_OPERATIONS = TimeSpan.FromMilliseconds(1000);

        [Fact]
        public async Task Cancelled_cancellation_token_throws_a_TaskCanceledException()
        {
            // Arrange
            var nativeTag = new Mock<INativeTag>();

            nativeTag                                                       // The initial creation of the tag object returns a status, so we return pending
                .Setup(m => m.plc_tag_create(It.IsAny<string>(), 0))
                .Returns((int)Status.Pending);

            nativeTag                                                       // Subsequent calls to determine the tag status should still return pending
                .Setup(m => m.plc_tag_status(It.IsAny<int>()))
                .Returns((int)Status.Pending);

            var tag = new NativeTagWrapper(nativeTag.Object);
            var cts = new CancellationTokenSource();

            // Act
            cts.CancelAfter(REALISTIC_TIMEOUT_FOR_ALL_OPERATIONS);

            // Assert
            await Assert.ThrowsAsync<TaskCanceledException>(async () => {
                await tag.InitializeAsync(cts.Token);
            });
        }


        [Fact]
        public async Task Timeout_throws_a_LibPlcTagException()
        {
            // Arrange
            var nativeTag = new Mock<INativeTag>();

            nativeTag                                                       // The initial creation of the tag object returns a status, so we return pending
                .Setup(m => m.plc_tag_create(It.IsAny<string>(), 0))
                .Returns((int)Status.Pending);

            nativeTag                                                       // Subsequent calls to determine the tag status should still return pending
                .Setup(m => m.plc_tag_status(It.IsAny<int>()))
                .Returns((int)Status.Pending);

            var tag = new NativeTagWrapper(nativeTag.Object)
            {
                Timeout = REALISTIC_TIMEOUT_FOR_ALL_OPERATIONS
            };

            // Act


            // Assert
            var ex  = await Assert.ThrowsAsync<LibPlcTagException>(async () => {
                await tag.InitializeAsync();
            });

            Assert.Equal(Status.ErrorTimeout.ToString(), ex.Message);
        }

        [Fact]
        public async Task Timeout_returns_pending_but_eventually_ok()
        {
            // Arrange
            var nativeTag = GetMock();

            var tag = new NativeTagWrapper(nativeTag.Object)
            {
                Timeout = REALISTIC_TIMEOUT_FOR_ALL_OPERATIONS
            };

            // Act
            await tag.InitializeAsync();

            // Assert
            Assert.Equal(Status.Ok, tag.GetStatus());
        }

        [Fact]
        public async Task AsyncRead_completes_within_timeout_period()
        {
            // Arrange
            var nativeTag = GetMock();

            var tag = new NativeTagWrapper(nativeTag.Object)
            {
                Timeout = REALISTIC_TIMEOUT_FOR_ALL_OPERATIONS
            };

            // Act
            await tag.ReadAsync();

            // Assert
            Assert.Equal(Status.Ok, tag.GetStatus());
        }


        Mock<INativeTag> GetMock()
        {
            const int tagId = 11;

            plctag.callback_func callback = null;

            var nativeTag = new Mock<INativeTag>();

            // The NativeTagWrapper should provide the native tag with a callback.
            // We will store this locally and call it ...
            nativeTag
                .Setup(m => m.plc_tag_register_callback(It.IsAny<int>(), It.IsAny<plctag.callback_func>()))
                .Callback<int, plctag.callback_func>((tagId, callbackFunc) => callback = callbackFunc);

            // ... when a create call occurs, and ..
            nativeTag
                .Setup(m => m.plc_tag_create(It.IsAny<string>(), 0))
                .Callback<string, int>(async (attributeString, timeout) =>
                {
                    await Task.Delay(REALISTIC_LATENCY_FOR_CREATE);
                    callback?.Invoke(tagId, (int)EVENT_CODES.PLCTAG_EVENT_CREATED, (int)STATUS_CODES.PLCTAG_STATUS_OK);
                });

            // ... when a read call occurs
            nativeTag
                .Setup(m => m.plc_tag_read(It.IsAny<int>(), 0))
                .Callback<int, int>(async (tagId, timeout) =>
                {
                    callback?.Invoke(tagId, (int)EVENT_CODES.PLCTAG_EVENT_READ_STARTED, (int)STATUS_CODES.PLCTAG_STATUS_OK);
                    await Task.Delay(REALISTIC_LATENCY_FOR_READ);
                    callback?.Invoke(tagId, (int)EVENT_CODES.PLCTAG_EVENT_READ_COMPLETED, (int)STATUS_CODES.PLCTAG_STATUS_OK);
                });

            return nativeTag;
        }

    }
}
